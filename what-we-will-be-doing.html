<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitOps Workshop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .command-block {
        background-color: #1f2937;
        color: #d1d5db;
        padding: 1rem;
        border-radius: 0.5rem;
        overflow-x: auto;
        font-family: "Courier New", Courier, monospace;
        font-size: 0.875rem;
        line-height: 1.25rem;
        margin-bottom: 1rem;
      }
      .code-block {
        background-color: #1f2937;
        color: #d1d5db;
        padding: 1rem;
        border-bottom-left-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
        overflow-x: auto;
        font-family: "Courier New", Courier, monospace;
        font-size: 0.875rem;
        line-height: 1.25rem;
        margin-bottom: 1rem;
      }
      .code-block-title {
        background-color: #374151;
        color: #e5e7eb;
        padding: 0.5rem 1rem;
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .copy-button {
        background-color: #4f46e5;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
      }
      .copy-button:hover {
        background-color: #4338ca;
      }
      .pro-tip {
        background-color: #eef2ff;
        border-left: 4px solid #4f46e5;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 0.25rem;
      }
    </style>
  </head>
  <body class="bg-gray-50 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
      <header class="text-center mb-10">
        <h1 class="text-4xl font-bold text-gray-900">
          The Declarative State: A GitOps Workshop
        </h1>
        <p class="mt-2 text-lg text-gray-600">
          A hands-on guide to building a secure, multi-environment platform
          locally.
        </p>
      </header>

      <div class="max-w-4xl mx-auto">
        <div class="mb-12 bg-white p-8 rounded-lg shadow-sm">
          <h2 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-4">
            The Core Philosophy: What is GitOps? 🤔
          </h2>
          <p class="mb-4 text-gray-700">
            At its heart, GitOps is a way of managing infrastructure and
            applications where <strong>Git is the one and only source of
            truth</strong>. Imagine your entire system's desired state—every
            application, every piece of infrastructure, every
            configuration—is described in a Git repository. Specialized software
            agents running in your cluster are constantly watching this
            repository. Their only job is to make sure the live system matches
            what's described in Git.
          </p>

          <h4 class="text-xl font-semibold mb-3">The Core Principles:</h4>
          <ul class="list-disc list-inside space-y-2 mb-6 text-gray-700">
            <li>
              <strong>Declarative:</strong> Your Git repo contains files (like
              Kubernetes YAML) that declare the desired state of your system. You
              say <em>what</em> you want, not <em>how</em> to get there.
            </li>
            <li>
              <strong>Versioned and Immutable:</strong> Git is the source of
              truth. Every change is a git commit, giving you a complete,
              auditable history of every change to your system. You can easily
              see who changed what, when, and why. You can even `git revert` to
              roll back to a previous state.
            </li>
            <li>
              <strong>Pulled Automatically:</strong> Software agents pull the
              desired state from Git. This is a crucial security point. You
              don't push changes from an external system. The cluster itself is
              responsible for pulling and applying changes, meaning you don't
              need to give external CI systems direct admin access to your
              cluster.
            </li>
            <li>
              <strong>Continuously Reconciled:</strong> The agents constantly
              compare the live state with the desired state in Git. If there's
              any difference (a "drift"), they automatically fix it. This makes
              the system self-healing.
            </li>
          </ul>

          <h3 class="text-2xl font-semibold mb-4 pt-4 border-t">
            The Workshop Toolchain Explained 🛠️
          </h3>
          <div class="space-y-4 mb-6">
            <div>
              <h4 class="text-xl font-semibold">1. ArgoCD: The GitOps Enforcer</h4>
              <p class="text-gray-700">
                ArgoCD is the agent that lives in your cluster. It constantly
                watches your Git repository and compares it to the live state of
                the cluster. If they don't match, ArgoCD applies the necessary
                changes. It's the engine of our GitOps workflow.
              </p>
            </div>
            <div>
              <h4 class="text-xl font-semibold">2. Kustomize: The Environment Customizer</h4>
              <p class="text-gray-700">
                Kustomize provides a template-free way to customize application
                configuration. You define a common `base` set of manifests and
                then create `overlays` for each environment (e.g., staging,
                production) that only contain the differences. It's a simple,
                powerful way to manage multiple environments without duplicating
                code.
              </p>
            </div>
          </div>

          <h3 class="text-2xl font-semibold mb-4 pt-4 border-t">
            Essential Kubernetes Concepts 🧠
          </h3>
          <div class="space-y-4 text-gray-700">
            <div>
              <h4 class="text-xl font-semibold">Context</h4>
              <p>
                A context in Kubernetes is a group of access parameters. Each context contains a Kubernetes cluster, a user, and a namespace.
                The current context is the cluster that is currently the default for kubectl: all kubectl commands run against that cluster.
                Each of the context that have been used will be available on your .kubeconfig.
              </p>
            </div>
            <div>
              <h4 class="text-xl font-semibold">Namespaces</h4>
              <p>
                Think of them as <strong>virtual clusters</strong> or logical partitions. They
                are used to organize resources and apply security policies, like
                separating our <strong>staging</strong> and <strong>production</strong> environments.
              </p>
            </div>
            <div>
              <h4 class="text-xl font-semibold">CNI (Container Network Interface)</h4>
              <p>
                The CNI is the component responsible for networking between your
                pods. It gives them IP addresses and sets up the necessary
                routes so they can communicate. For <em>kind</em>, this is handled for
                you automatically.
              </p>
            </div>
          </div>
        </div>
        <h2 class="text-2xl font-semibold mb-4">Introduction</h2>
        <p class="mb-4">
          Welcome! This workshop will guide you through setting up a complete
          GitOps environment on your local machine. You will learn how to manage
          multiple environments (`staging`, `production`) with minimal code
          duplication using GitOps principles.
        </p>
        <p>
          The entire "Git repository" for this workshop is simulated by the file
          structure outlined below. You will create these files on your local
          machine.
        </p>

        <div class="pro-tip">
          <p>
            <strong class="font-semibold">Prerequisites:</strong> Before you
            start, please ensure you have the following tools installed on your
            system: <strong>Docker</strong>, <strong>kubectl</strong>,
            <strong>Helm</strong>, and <strong>kind</strong>.
          </p>
        </div>

        <h2 class="text-2xl font-semibold mt-8 mb-4">
          Step 1: Project Directory Structure
        </h2>
        <p class="mb-4">
          First, create the following directory structure on your local machine.
          This will simulate our Git repository.
        </p>
        <div id="directory-structure">
          <div class="code-block-title">
            <span>Directory Structure</span>
          </div>
          <pre
            id="directory-structure-code"
            class="code-block"
          >
gitops-workshop/
├── setup-scripts/
│   ├── 00-verify-tools.sh
│   ├── 01-create-cluster.sh
│   ├── 02-install-tools.sh
│   ├── 03-setup-database.sh
│   ├── 04-create-argocd-applications.sh
│   ├── 05-self-healing-demo.sh
│   └── 99-cleanup.sh
└── infra-manifests/
    ├── database/
    │   ├── postgresql.yaml
    │   └── secrets.yaml
    └── apps/
        └── db-pinger/
            ├── base/
            │   ├── deployment.yaml
            │   ├── service.yaml
            │   ├── serviceaccount.yaml
            │   └── kustomization.yaml
            └── overlays/
                ├── staging/
                │   ├── configmap.yaml
                │   └── kustomization.yaml
                └── production/
                    ├── configmap.yaml
                    └── kustomization.yaml
          </pre>
        </div>

        <h2 class="text-2xl font-semibold mt-8 mb-4">
          Step 2: The Setup Scripts
        </h2>
        <p>
          These scripts automate the creation and configuration of your local
          platform.
        </p>

        <div id="script1">
          <div class="code-block-title">
            <span>setup-scripts/01-create-cluster.sh</span>
            <button class="copy-button" onclick="copyCode('script1-code')">
              Copy
            </button>
          </div>
          <pre id="script1-code" class="code-block">
#!/bin/bash
set -euo pipefail

CLUSTER_NAME="gitops-workshop"

echo "🌐 Creating kind cluster: ${CLUSTER_NAME}"

kind create cluster --name "${CLUSTER_NAME}" --config=../kind-cluster-config.yaml

echo "✅ Cluster '${CLUSTER_NAME}' created successfully."
echo "👉 Your kubectl context is now set to 'kind-${CLUSTER_NAME}'"

          </pre>
        </div>

        <div id="script2">
          <div class="code-block-title">
            <span>setup-scripts/02-install-tools.sh</span>
            <button class="copy-button" onclick="copyCode('script2-code')">
              Copy
            </button>
          </div>
          <pre id="script2-code" class="code-block">
#!/bin/bash
set -euo pipefail

echo "🚀 Installing or Upgrading ArgoCD..."
# Use 'helm upgrade --install' to make the script idempotent.
# This command will install the chart if it's not present, or upgrade it if it is.
# The --create-namespace flag handles namespace creation, removing the need for a separate kubectl command.
helm repo add argo https://argoproj.github.io/argo-helm || true
helm upgrade --install argocd argo/argo-cd \
  --namespace argocd \
  --create-namespace \
  --version 5.52.0 \
  --wait

echo "🔧 Configuring ArgoCD memory limits to prevent OOM issues..."
# Wait for ArgoCD to be fully deployed
kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s

# The patch commands already use '|| true' to avoid errors if they fail, which is fine.
# Patch StatefulSet with memory limits
kubectl patch statefulset argocd-application-controller -n argocd -p '{"spec":{"template":{"spec":{"containers":[{"name":"argocd-application-controller","resources":{"limits":{"memory":"512Mi","cpu":"500m"},"requests":{"memory":"256Mi","cpu":"250m"}}}]}}}}' || true

# Patch Deployments with memory limits
kubectl patch deployment argocd-repo-server -n argocd --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/resources", "value": {"limits": {"memory": "512Mi", "cpu": "500m"}, "requests": {"memory": "256Mi", "cpu": "250m"}}}]' || true
kubectl patch deployment argocd-server -n argocd --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/resources", "value": {"limits": {"memory": "512Mi", "cpu": "500m"}, "requests": {"memory": "256Mi", "cpu": "250m"}}}]' || true
kubectl patch deployment argocd-applicationset-controller -n argocd --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/resources", "value": {"limits": {"memory": "256Mi", "cpu": "250m"}, "requests": {"memory": "128Mi", "cpu": "125m"}}}]' || true

echo "✅ ArgoCD memory configuration applied!"
echo "✅ All platform tools installed successfully!"</pre>
        </div>

        <h2 class="text-2xl font-semibold mt-8 mb-4">
          Step 3: Infrastructure & Application Manifests
        </h2>
        <p>These YAML files define our platform and application state.</p>

        <div id="db-postgresql">
          <div class="code-block-title">
            <span>infra-manifests/database/postgresql.yaml</span>
            <button
              class="copy-button"
              onclick="copyCode('db-postgresql-code')"
            >
              Copy
            </button>
          </div>
          <pre id="db-postgresql-code" class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgresql
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgresql
        image: postgres:14
        env:
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: postgres
        - name: POSTGRES_PASSWORD
          value: postgres
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgresql-data
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgresql-data
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: postgresql
  namespace: default
spec:
  selector:
    app: postgresql
  ports:
  - protocol: TCP
    port: 5432
    targetPort: 5432
</pre>
        </div>

        <div id="db-secrets">
          <div class="code-block-title">
            <span>infra-manifests/database/secrets.yaml</span>
            <button class="copy-button" onclick="copyCode('db-secrets-code')">
              Copy
            </button>
          </div>
          <pre id="db-secrets-code" class="code-block">
apiVersion: v1
kind: Secret
metadata:
  name: db-pinger-conn
  namespace: staging
type: Opaque
stringData:
  username: postgres
  password: postgres
  endpoint: postgresql.default.svc:5432
  DB_HOST: postgresql.default.svc
  DB_PORT: "5432"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-pinger-conn
  namespace: production
type: Opaque
stringData:
  username: postgres
  password: postgres
  endpoint: postgresql.default.svc:5432
  DB_HOST: postgresql.default.svc
  DB_PORT: "5432"
</pre
          >
        </div>

        <div id="app-dep">
          <div class="code-block-title">
            <span>infra-manifests/apps/db-pinger/base/deployment.yaml</span>
            <button class="copy-button" onclick="copyCode('app-dep-code')">
              Copy
            </button>
          </div>
          <pre id="app-dep-code" class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db-pinger
  labels:
    app: db-pinger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db-pinger
  template:
    metadata:
      labels:
        app: db-pinger
    spec:
      serviceAccountName: db-pinger-sa
      containers:
      - name: db-pinger
        image: postgres:14-alpine # Using postgres client as a pinger
        command: ["/bin/sh", "-c"]
        args:
          - |
            apk add --no-cache netcat-openbsd;
            echo "--- Starting DB Pinger ---";
            echo "Connecting to real PostgreSQL database...";

            # Get database connection details from environment
            DB_HOST="${DB_HOST:-postgresql.default.svc}"
            DB_PORT="${DB_PORT:-5432}"

            echo "Pinging DB host: $DB_HOST on port $DB_PORT";

            # Loop forever, checking the connection
            while true; do
              if nc -z -w5 "$DB_HOST" "$DB_PORT"; then
                echo "SUCCESS: Connection to $DB_HOST:$DB_PORT is open."
              else
                echo "FAILURE: Connection to $DB_HOST:$DB_PORT is closed."
              fi;
              sleep 10;
            done
        envFrom:
        - configMapRef:
            name: db-pinger-config
        - secretRef:
            name: db-pinger-conn
</pre
          >
        </div>

        <div id="app-svc">
          <div class="code-block-title">
            <span>infra-manifests/apps/db-pinger/base/service.yaml</span>
            <button class="copy-button" onclick="copyCode('app-svc-code')">
              Copy
            </button>
          </div>
          <pre id="app-svc-code" class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: db-pinger
spec:
  selector:
    app: db-pinger
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080 # Dummy port, app doesn't serve traffic
</pre
          >
        </div>

        <div id="app-kustomize-base">
          <div class="code-block-title">
            <span>infra-manifests/apps/db-pinger/base/kustomization.yaml</span>
            <button
              class="copy-button"
              onclick="copyCode('app-kustomize-base-code')"
            >
              Copy
            </button>
          </div>
          <pre id="app-kustomize-base-code" class="code-block">
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

# All resources are managed through Git
resources:
- deployment.yaml
- service.yaml
- serviceaccount.yaml

configMapGenerator:
- name: db-pinger-config
  literals:
  # These will be overridden by overlays
  - ENVIRONMENT="base"
  - LOG_LEVEL="info"

# Database connection is provided via db-pinger-conn secret created by setup script
</pre
          >
        </div>

        <div id="app-sa-base">
          <div class="code-block-title">
            <span>infra-manifests/apps/db-pinger/base/serviceaccount.yaml</span>
            <button class="copy-button" onclick="copyCode('app-sa-base-code')">
              Copy
            </button>
          </div>
          <pre id="app-sa-base-code" class="code-block">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: db-pinger-sa
secrets:
- name: db-pinger-conn
</pre
          >
        </div>

        <div id="overlay-staging-cm">
          <div class="code-block-title">
            <span
              >infra-manifests/apps/db-pinger/overlays/staging/configmap.yaml</span
            >
            <button
              class="copy-button"
              onclick="copyCode('overlay-staging-cm-code')"
            >
              Copy
            </button>
          </div>
          <pre id="overlay-staging-cm-code" class="code-block">
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-pinger-config
data:
  ENVIRONMENT: "staging"
  LOG_LEVEL: "debug"
</pre
          >
        </div>

        <div id="overlay-staging-kustomize">
          <div class="code-block-title">
            <span
              >infra-manifests/apps/db-pinger/overlays/staging/kustomization.yaml</span
            >
            <button
              class="copy-button"
              onclick="copyCode('overlay-staging-kustomize-code')"
            >
              Copy
            </button>
          </div>
          <pre id="overlay-staging-kustomize-code" class="code-block">
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: staging
resources:
- ../../base

patches:
- path: configmap.yaml
  target:
    kind: ConfigMap
    name: db-pinger-config
</pre
          >
        </div>

        <div id="overlay-prod-cm">
          <div class="code-block-title">
            <span
              >infra-manifests/apps/db-pinger/overlays/production/configmap.yaml</span
            >
            <button
              class="copy-button"
              onclick="copyCode('overlay-prod-cm-code')"
            >
              Copy
            </button>
          </div>
          <pre id="overlay-prod-cm-code" class="code-block">
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-pinger-config
data:
  ENVIRONMENT: "production"
  LOG_LEVEL: "info"
</pre
          >
        </div>

        <div id="overlay-prod-kustomize">
          <div class="code-block-title">
            <span
              >infra-manifests/apps/db-pinger/overlays/production/kustomization.yaml</span
            >
            <button
              class="copy-button"
              onclick="copyCode('overlay-prod-kustomize-code')"
            >
              Copy
            </button>
          </div>
          <pre id="overlay-prod-kustomize-code" class="code-block">
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: production
resources:
- ../../base

patches:
- path: configmap.yaml
  target:
    kind: ConfigMap
    name: db-pinger-config
</pre
          >
        </div>

        <h2 class="text-2xl font-semibold mt-8 mb-4">
          Step 4: Running the Workshop
        </h2>
        <p>Execute these commands in order from your terminal.</p>

        <ol class="list-decimal list-inside space-y-6">
          <li>
            <strong>Create the Cluster:</strong>
            <p>Make the script executable and run it.</p>
            <pre class="command-block">
chmod +x setup-scripts/01-create-cluster.sh && ./setup-scripts/01-create-cluster.sh</pre
            >
          </li>
          <li>
            <strong>Install Platform Tools:</strong>
            <pre class="command-block">
chmod +x setup-scripts/02-install-tools.sh && ./setup-scripts/02-install-tools.sh</pre
            >
          </li>
          <li>
            <strong>Setup Database:</strong>
            <pre class="command-block">
chmod +x setup-scripts/03-setup-database.sh && ./setup-scripts/03-setup-database.sh</pre
            >
          </li>
          <li>
            <strong>Deploy the ArgoCD App of Apps (The GitOps Trigger):</strong>
            <p class="mt-2">First, create the namespaces.</p>
            <pre class="command-block">
kubectl create ns staging || true; kubectl create ns production || true</pre
            >
            <p class="mt-2">
              Now, create the ArgoCD application manifests that point to our
              Kustomize overlays.
            </p>
            <div id="argocd-apps">
              <div class="code-block-title">
                <span>argocd-applications.yaml (Apply this file manually)</span>
                <button
                  class="copy-button"
                  onclick="copyCode('argocd-apps-code')"
                >
                  Copy
                </button>
              </div>
              <pre id="argocd-apps-code" class="code-block">
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: db-pinger-staging
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-username/your-repo.git # CHANGE THIS
    targetRevision: HEAD
    path: infra-manifests/apps/db-pinger/overlays/staging
  destination:
    server: https://kubernetes.default.svc
    namespace: staging
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: db-pinger-production
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-username/your-repo.git # CHANGE THIS
    targetRevision: HEAD
    path: infra-manifests/apps/db-pinger/overlays/production
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
</pre
              >
            </div>
            <div class="pro-tip">
              <p>
                <strong class="font-semibold">Important:</strong> Before
                applying the `argocd-applications.yaml` file, you must push your
                local `gitops-workshop` directory to a real GitHub repository
                and update the `repoURL` in the file to point to it.
              </p>
            </div>
            <pre class="command-block">
kubectl apply -f argocd-applications.yaml</pre
            >
          </li>
          <li>
            <strong>Access ArgoCD and Observe:</strong>
            <p class="mt-2">Get the ArgoCD admin password:</p>
            <pre class="command-block">
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo</pre
            >
            <p class="mt-2">Port-forward to the ArgoCD UI:</p>
            <pre class="command-block">
kubectl port-forward svc/argocd-server -n argocd 8081:443</pre
            >
            <p class="mt-2">
              Open
              <a
                href="https://localhost:8081"
                target="_blank"
                class="text-indigo-600 hover:underline"
                >https://localhost:8081</a
              >
              in your browser. Log in with username `admin` and the password you
              just retrieved. You should see your two applications syncing!
            </p>
          </li>
        </ol>
      </div>
    </div>
    <script>
      function copyCode(elementId) {
        const codeEl = document.getElementById(elementId);
        const text = codeEl.innerText;

        const tempTextArea = document.createElement("textarea");
        tempTextArea.value = text;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        try {
          document.execCommand("copy");
          // Optional: Show a temporary success message
        } catch (err) {
          console.error("Failed to copy text: ", err);
        }
        document.body.removeChild(tempTextArea);
      }
    </script>
  </body>
</html>
